// push argument 1         // sets THAT, the base address of the
@1 // 0
D=A // 1
@ARG // 2
D=M+D // 3
A=D // 4
D=M // 5
@SP // 6
A=M // 7
M=D // 8
@SP // 9
M=M+1 // 10
// pop pointer 1           // that segment, to argument[1]
@R4 // 11
D=A // 12
@R13 // 13
M=D // 14
@SP // 15
M=M-1 // 16
@SP // 17
A=M // 18
D=M // 19
@R13 // 20
A=M // 21
M=D // 22
// push constant 0         // sets the series' first and second
@0 // 23
D=A // 24
@SP // 25
A=M // 26
M=D // 27
@SP // 28
M=M+1 // 29
// pop that 0              // elements to 0 and 1, respectively
@0 // 30
D=A // 31
@THAT // 32
D=M+D // 33
A=D // 34
D=A // 35
@R13 // 36
M=D // 37
@SP // 38
M=M-1 // 39
@SP // 40
A=M // 41
D=M // 42
@R13 // 43
A=M // 44
M=D // 45
// push constant 1
@1 // 46
D=A // 47
@SP // 48
A=M // 49
M=D // 50
@SP // 51
M=M+1 // 52
// pop that 1
@1 // 53
D=A // 54
@THAT // 55
D=M+D // 56
A=D // 57
D=A // 58
@R13 // 59
M=D // 60
@SP // 61
M=M-1 // 62
@SP // 63
A=M // 64
D=M // 65
@R13 // 66
A=M // 67
M=D // 68
// push argument 0         // sets n, the number of remaining elements
@0 // 69
D=A // 70
@ARG // 71
D=M+D // 72
A=D // 73
D=M // 74
@SP // 75
A=M // 76
M=D // 77
@SP // 78
M=M+1 // 79
// push constant 2         // to be computed, to argument[0] minus 2,
@2 // 80
D=A // 81
@SP // 82
A=M // 83
M=D // 84
@SP // 85
M=M+1 // 86
// sub                     // since 2 elements were already computed.
@SP // 87
M=M-1 // 88
@SP // 89
A=M // 90
D=M // 91
@SP // 92
M=M-1 // 93
@SP // 94
A=M // 95
M=M-D // 96
@SP // 97
M=M+1 // 98
// pop argument 0
@0 // 99
D=A // 100
@ARG // 101
D=M+D // 102
A=D // 103
D=A // 104
@R13 // 105
M=D // 106
@SP // 107
M=M-1 // 108
@SP // 109
A=M // 110
D=M // 111
@R13 // 112
A=M // 113
M=D // 114
// label LOOP
(FibonacciSeries:LOOP) // 115
// push argument 0
@0 // 116
D=A // 117
@ARG // 118
D=M+D // 119
A=D // 120
D=M // 121
@SP // 122
A=M // 123
M=D // 124
@SP // 125
M=M+1 // 126
// if-goto COMPUTE_ELEMENT // if n > 0, goto COMPUTE_ELEMENT
@SP // 127
M=M-1 // 128
@SP // 129
A=M // 130
D=M // 131
@FibonacciSeries:COMPUTE_ELEMENT // 132
D;JNE // 133
// goto END                // otherwise, goto END
@FibonacciSeries:END // 134
0;JMP // 135
// label COMPUTE_ELEMENT
(FibonacciSeries:COMPUTE_ELEMENT) // 136
// push that 0
@0 // 137
D=A // 138
@THAT // 139
D=M+D // 140
A=D // 141
D=M // 142
@SP // 143
A=M // 144
M=D // 145
@SP // 146
M=M+1 // 147
// push that 1
@1 // 148
D=A // 149
@THAT // 150
D=M+D // 151
A=D // 152
D=M // 153
@SP // 154
A=M // 155
M=D // 156
@SP // 157
M=M+1 // 158
// add
@SP // 159
M=M-1 // 160
@SP // 161
A=M // 162
D=M // 163
@SP // 164
M=M-1 // 165
@SP // 166
A=M // 167
M=M+D // 168
@SP // 169
M=M+1 // 170
// pop that 2
@2 // 171
D=A // 172
@THAT // 173
D=M+D // 174
A=D // 175
D=A // 176
@R13 // 177
M=D // 178
@SP // 179
M=M-1 // 180
@SP // 181
A=M // 182
D=M // 183
@R13 // 184
A=M // 185
M=D // 186
// push pointer 1
@R4 // 187
D=M // 188
@SP // 189
A=M // 190
M=D // 191
@SP // 192
M=M+1 // 193
// push constant 1
@1 // 194
D=A // 195
@SP // 196
A=M // 197
M=D // 198
@SP // 199
M=M+1 // 200
// add
@SP // 201
M=M-1 // 202
@SP // 203
A=M // 204
D=M // 205
@SP // 206
M=M-1 // 207
@SP // 208
A=M // 209
M=M+D // 210
@SP // 211
M=M+1 // 212
// pop pointer 1
@R4 // 213
D=A // 214
@R13 // 215
M=D // 216
@SP // 217
M=M-1 // 218
@SP // 219
A=M // 220
D=M // 221
@R13 // 222
A=M // 223
M=D // 224
// push argument 0
@0 // 225
D=A // 226
@ARG // 227
D=M+D // 228
A=D // 229
D=M // 230
@SP // 231
A=M // 232
M=D // 233
@SP // 234
M=M+1 // 235
// push constant 1
@1 // 236
D=A // 237
@SP // 238
A=M // 239
M=D // 240
@SP // 241
M=M+1 // 242
// sub
@SP // 243
M=M-1 // 244
@SP // 245
A=M // 246
D=M // 247
@SP // 248
M=M-1 // 249
@SP // 250
A=M // 251
M=M-D // 252
@SP // 253
M=M+1 // 254
// pop argument 0
@0 // 255
D=A // 256
@ARG // 257
D=M+D // 258
A=D // 259
D=A // 260
@R13 // 261
M=D // 262
@SP // 263
M=M-1 // 264
@SP // 265
A=M // 266
D=M // 267
@R13 // 268
A=M // 269
M=D // 270
// goto LOOP
@FibonacciSeries:LOOP // 271
0;JMP // 272
// label END
(FibonacciSeries:END) // 273
